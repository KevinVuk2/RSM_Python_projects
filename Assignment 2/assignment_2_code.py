# -*- coding: utf-8 -*-
"""Assignment_2_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_mkgrfuyHd0zarlwqk5F6ys_ivuY159k
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.api as sm
import patsy
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import plot_tree
pd.options.mode.chained_assignment = None  # default='warn'

insurance = pd.read_csv('insurance.csv')
insurance.head()

#Exercise1

# Define age bins and labels
age_bins = [18, 30, 40, 50, 60, 70]
age_labels = ['[18-30)', '[30-40)', '[40-50)', '[50-60)', '[60-70)']

# Create age groups
insurance['age_group'] = pd.cut(insurance['age'], bins=age_bins, labels=age_labels, right=False)

# Calculate average charges for smokers and non-smokers in each age group
avg_charges = insurance.groupby(['age_group', 'smoker'], observed=True)['charges'].mean().unstack()

# Plot the bar chart
avg_charges.plot(kind='bar', figsize=(10, 6),rot=0)
plt.title("Average Medical Charges by Age Group and Smoking Status")
plt.xlabel("Age Group")
plt.ylabel("Average Charges")
plt.legend(title="Smoker")
plt.show()

# Find the age group with the largest difference in charges between smokers and non-smokers
avg_charges['difference'] = abs(avg_charges['yes'] - avg_charges['no'])
max_diff_age_group = avg_charges['difference'].idxmax()
max_diff_value = avg_charges['difference'].max()

print(max_diff_age_group)
print(f'{max_diff_value:.2f}')

#Excercise2

# Select columns for correlation matrix
numerical_data = insurance[['charges', 'age', 'bmi', 'children']]

# Calculate correlation matrix
correlation_matrix = numerical_data.corr()
# Plot the heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Numerical Variables in Insurance Dataset')
plt.show()

# Identify the strongest correlation with 'charges'
strongest_correlation = correlation_matrix['charges'].drop('charges').abs().idxmax()
strongest_correlation

#Exercise3

#Set 'charges' as the target variable, and all other columns are predictors
formula = 'charges ~ age + gender + bmi + children + smoker + region'
y, X = patsy.dmatrices(formula, data=insurance, return_type='dataframe')

# Build the linear regression model
model = sm.OLS(y, X).fit()

# Get the summary of the model to check the significance of each variable
model_summary = model.summary()
print(model_summary)

#Exercise5

#a)

#Calculate residuals
insurance['predicted_charges'] = model.predict(X)
insurance['residuals'] = insurance['charges'] - insurance['predicted_charges']

#Plot the residuals
plt.figure(figsize=(10, 6))
sns.histplot(insurance['residuals'], bins=30, kde=True,color='blue')
plt.title('Distribution of Residuals')
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.show()

#b)

#Subset for residuals and predicted charges
residual_vs_predicted = insurance[['residuals', 'predicted_charges']]

#Plot the comparison of residuals vs predicted_charges
plt.figure(figsize=(10, 6))
plt.scatter(residual_vs_predicted['predicted_charges'], residual_vs_predicted['residuals'], alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Charges')
plt.ylabel('Residuals')
plt.title('Residuals vs. Predicted Charges')
plt.show()

#Exercise6

#Create log_charges with charges
insurance['log_charges'] = np.log(insurance['charges'])

#Prepare the data
formula_log = 'log_charges ~ age + gender + bmi + children + smoker + region'
y_log, X_log = patsy.dmatrices(formula_log, data=insurance, return_type='dataframe')

#Build the linear regression model
model_log = sm.OLS(y_log, X_log).fit()

#Check significant of each variable
model_log_summary = model_log.summary()
print(model_log_summary)

#a)
model_log_age = model_log.params['age']
print(f"coef of 'age' is: {model_log_age:.4f}")

#b)

#Calculate residual of log_charges
insurance['predicted_log_charges'] = model_log.predict(X_log)
insurance['residuals_log_charges'] = insurance['log_charges'] - insurance['predicted_log_charges']

#Plot the residual_log
plt.figure(figsize=(10, 6))
sns.histplot(insurance['residuals_log_charges'], bins=30, kde=True,color='blue')
plt.title('Distribution of Residuals')
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.show()

#c

#Plot the comparison of residuals_log_charges vs predicted_log_charges
plt.figure(figsize=(10, 6))
plt.scatter(insurance['predicted_log_charges'], insurance['residuals_log_charges'], alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Charges')
plt.ylabel('Residuals')
plt.title('Residuals vs. Predicted log_Charges')
plt.show()

#Exercise7

#Subset for R_squared and adjusted r_square
r_squared = model_log.rsquared
adj_r_squared = model_log.rsquared_adj

print(f"R-squared: {r_squared:.4f}")
print(f"Adjusted R-squared: {adj_r_squared:.4f}")

#Exercise8

#Import the new observations
new_obs = pd.DataFrame({
    'age': [25, 45, 32, 54, 29],
    'gender': ['male', 'female', 'male', 'female', 'female'],
    'bmi': [28.0, 35.2, 30.5, 24.7, 22.8],
    'children': [1, 3, 0, 2, 1],
    'smoker': ['no', 'yes', 'no', 'yes', 'yes'],
    'region': ['northeast', 'southeast', 'northwest', 'southwest', 'southeast']
})

#Prepare the data for prediction using the formula from the original model
X_new = patsy.dmatrix('age + gender + bmi + children + smoker + region', data=new_obs, return_type='dataframe')

#Use the model developed in question 6 to make predictions for the new data
predicted_log_charges = model_log.predict(X_new)

#Convert the predicted log charges back to original charges (by applying the exponential function)
new_obs['charges'] = np.exp(predicted_log_charges)
new_obs

#Exercise9

#Create "binary_charges"
mu= insurance['charges'].mean()
insurance['binary_charges'] = np.where(insurance['charges'] <= mu, 0, 1)

#Calculate the percentage of observations assigned to each class of 'binary_charges'
class_percentage = insurance['binary_charges'].value_counts(normalize=True) * 100

print(f'% of observations assigned to class 0: {class_percentage[0]:.2f}')
print(f'% of observations assigned to class 1: {class_percentage[1]:.2f}')

#Exercise10

#Prepare the data for the logistic regression model using patsy to create the design matrix
formula_logit = 'binary_charges ~ age + gender + bmi + children + smoker + region'
y_logit, X_logit = patsy.dmatrices(formula_logit, data=insurance, return_type='dataframe')

# Build the logistic regression model
logit_model = sm.Logit(y_logit, X_logit).fit()

# Get the summary of the logistic regression model
print(logit_model.summary())
odds_ratio = np.exp(logit_model.params)
odds_ratio

#Exercise12

# Prepare the data for prediction using the formula from the original model
X_newer = patsy.dmatrix('age + gender + bmi + children + smoker + region', data=new_obs, return_type='dataframe')

#Make predictions for the new data
predict_binary_charges = logit_model.predict(X_newer)

# Convert the predicted log charges back to original charges
new_obs['binary_charges'] = predict_binary_charges
new_obs

#Exercise13

#Create q1 and q3 as the first and third quartile of the charges variable
q1 = insurance['charges'].quantile(0.25)
q3 = insurance['charges'].quantile(0.75)
print(q1)
print(q3)
#Create 'multiclass_charges'
insurance['multiclass_charges'] = np.where(insurance['charges'] <= q1, 'low',
                                          np.where(insurance['charges'] >= q3, 'high', 'medium'))

#Calculate the percentage of observations assigned to each class of 'multiclass_charges
class_percentage = insurance['multiclass_charges'].value_counts(normalize=True) * 100

print(f'% of observations assigned to class low: {class_percentage["low"]:.2f}')
print(f'% of observations assigned to class medium: {class_percentage["medium"]:.2f}')
print(f'% of observations assigned to class high: {class_percentage["high"]:.2f}')

#Exercise14

#Prepare the data for the decision tree model
predictor_variables = ['age', 'gender', 'bmi', 'children', 'smoker', 'region']
X = pd.get_dummies(insurance[predictor_variables], drop_first=True)
Y = insurance['multiclass_charges']

#Build the decision tree model
tree = DecisionTreeClassifier(max_depth=4 , random_state=42)
tree.fit(X, Y)

# Get the number of leaf nodes in the tree
n_leaves = tree.get_n_leaves()
print(f"Number of leaf nodes in the decision tree: {n_leaves}")

#Exercise15

# Plot the decision tree
plt.figure(figsize=(20, 10))
plot_tree(tree, feature_names=X.columns, class_names=['low', 'medium', 'high'], filled=True, rounded=True)
plt.title("Decision Tree for Predicting multiclass_charges")
plt.show()

#Exercise16

#Prepare the new data for prediction
X_new_obs = pd.get_dummies(new_obs, drop_first=True)

#Align the new observation columns with the training set columns
X_new_obs = X_new_obs.reindex(columns=X.columns, fill_value=0)
print(X_new_obs)
#Use the decision tree model to predict multiclass_charges for new_obs
predicted_multiclass_charges = tree.predict(X_new_obs)

#Create a new column for the predicted multiclass charges for the new observations
new_obs['predicted_multiclass_charges'] = predicted_multiclass_charges
new_obs